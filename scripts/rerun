#!/usr/bin/env bash

# Events that occur within this time from an initial one are ignored
cooldown_s='0.250'
clear=''
verbose=''
poll_interval='1'  # Check for changes every second

function usage {
  echo "Rerun a given command every time filesystem changes are detected."
  echo ""
  echo "Usage: $(basename "$0") [OPTIONS] COMMAND"
  echo ""
  echo "  -c, --clear     Clear the screen before each execution of COMMAND."
  echo "  -v, --verbose   Print the name of the files that changed to cause"
  echo "                  each execution of COMMAND."
  echo "  -h, --help      Display this help and exit."
  echo ""
  echo "Run the given COMMAND, and then every time filesystem changes are"
  echo "detected in or below the current directory, run COMMAND again."
  echo "Changes within $cooldown_s seconds are grouped into one."
  echo ""
  echo "This is useful for running commands to regenerate visual output every"
  echo "time you hit [save] in your editor. For example, re-run tests, or"
  echo "refresh markdown or graphviz rendering."
  echo ""
  echo "COMMAND can only be a simple command, ie. \"executable arg arg...\"."
  echo "For compound commands, use:"
  echo ""
  echo "    rerun bash -c \"ls -l | grep ^d\""
  echo ""
  echo "Using this it's pretty easy to rig up ad-hoc GUI apps on the fly."
  echo "For example, every time you save a .dot file from the comfort of"
  echo "your favourite editor, rerun can execute GraphViz to render it to"
  echo "SVG, and refresh whatever GUI program you use to view that SVG."
  echo ""
  echo "COMMAND can't be a shell alias, and I don't understand why not."
}

while [ $# -gt 0 ]; do
  case "$1" in
    -c|--clear) clear='1';;
    -v|--verbose) verbose='1' ;;
    -h|--help) usage; exit;;
    *) break;;
  esac
  shift
done

function execute() {
  [ -n "$clear" ] && clear
  [ -n "$verbose" ] && echo "$@"
  "$@"
}

execute "$@"
last_run=$(date +%s)

# Find all files in the directory and get their modification times
get_file_signatures() {
  find . -type f \
    ! -path "*/\.git/*" \
    ! -name ".*\.swp" \
    ! -path "*/__pycache__/*" \
    ! -path "*/.cache/*" \
    ! -path "*/.pytest_cache/*" \
    -print0 | xargs -0 stat -f "%N %m" 2>/dev/null
}

# Get initial state
previous_signatures=$(get_file_signatures)

while true; do
  sleep $poll_interval

  current_signatures=$(get_file_signatures)

  # Check if anything changed
  if [[ "$current_signatures" != "$previous_signatures" ]]; then
    # Find which files changed for verbose mode
    if [ -n "$verbose" ]; then
      diff <(echo "$previous_signatures") <(echo "$current_signatures") | grep ">" | cut -d' ' -f2- | while read -r changed; do
        echo "$changed"
      done
    fi

    # Update signatures
    previous_signatures="$current_signatures"

    # Get current time
    now=$(date +%s)
    last_run_plus_cooldown=$(echo "$last_run + $cooldown_s" | bc)

    # Check if we're past the cooldown period
    if (( $(echo "$now > $last_run_plus_cooldown" | bc) )); then
      last_run=$now
      ( sleep "$cooldown_s" && execute "$@" ) &
    fi
  fi
done